1. Установка пакетов:
    $ npm install --save @nestjs/passport passport passport-jwt
    $ npm install --save-dev @types/passport-jwt

2. Процесс аутентификации с использованием JWT-токена осуществляется следующим образом:
    Запросы и мутации, которые требуют аутентификацию, должны быть обернуты в
    декоратор @UseGuards(AuthGuard('jwt')).
    AuthGuard('jwt') вызывает класс JwtStrategy, который "под капотом" валидирует JWT-токен
    с помощью секретного ключа, передаваемого в JwtModule через объект настроек,
    а также проверяет срок действия JWT-токена.
        Если валидация JWT-токена прошла успешно,
    JwtStrategy извлекает информацию из JWT-токена и передаёт полученный объект типа JwtPayload,
    содержащий id пользователя, в качестве параметра методу validate(jwtPayload: JwtPayload),
    в котором необходимо реализовать логику проверки наличия пользователя в базе данных и,
    если он существует, вернуть объект с данными пользователя.
    Эти данные будут автоматически добавлены в свойство Request.user.
    Обычно к объекту запроса добавляется свойство Request.user.id, содержащее id аутентифицированного пользователя.

2. Чтобы создать класс стратегии, необходимо расширить класс PassportStrategy,
который предоставляет основную функциональность Passport.js.

    Созданный класс стратегии должен быть декоринирован @Injectable()
    и зарегистрирован в списке провайдеров соответствующего модуля.

Например, JwtStrategy расширяет класс JwtStrategy из библиотеки passport-jwt,
поэтому вам необходимо импортировать JwtStrategy из библиотеки passport-jwt
и передать его в качестве параметра в конструктор класса PassportStrategy.
Аналогичным образом создаются и другие классы стратегий, например,
    LocalStrategy, GoogleStrategy, YandexStrategy.

 Чтобы использовать логику стратегии, класс которой мы расширяем,
 в конструкторе класса необходимо вызвать метод super, передав в качестве параметра объект настроек,

В качестве второго параметра в конструктор класса PassportStrategy можно передать название стратегии,
которое будет использоваться в декораторе @UseGuards(AuthGuard('refresh-jwt')) для вызова соответствующей стратегии.
Например,
    export class RefreshTokenStrategy extends PassportStrategy(
      Strategy,
      'refresh-jwt',
    )

3. Создать класс Guard, декорированный @Injectable(),
расширяющий класс AuthGuard из библиотеки @nestjs/passport,
который будет вызывать созданную стратегию,
зарегистрировать его в списке провадеров соответствующего модуля
и декорировать им резолверы, запросы и мутации, которые требуют аутентификации.
AuthGuard принимает в качестве параметра название стратегии,
которая будет им вызываться.

По умолчанию классы Strategy, импортируемые из библиотек уже имеют названия,
которые соответствуют названиям стратегий,
Например,
    import { Strategy } from 'passport-jwt';                - 'jwt'
    import { Strategy } from 'passport-google-oauth20';     - 'google'
    import { Strategy } from 'passport-yandex';             - 'yandex'

4. При использовании GraphQL в Guard требуется извлечь и вернуть объект Request из контекста GraphQL.
Для этого необходимо реализовать метод:
      getRequest(context: ExecutionContext) {
        const ctx = GqlExecutionContext.create(context);
        return ctx.getContext().req;
      }
Это требуется, т.к. JwtStrategy из библиотеки passport-jwt привязана к контексту HTTP,
а не контексту GraphQL.