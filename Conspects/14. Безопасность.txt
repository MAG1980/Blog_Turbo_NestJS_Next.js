1. Защита от атак типа XSS
    dangerouslySetInnerHTML — это свойство HTML-элементов в приложении React, которое позволяет программно устанавливать их содержимое.
Оно заменяет innerHTML, используемый в браузере DOM
 Чаще всего dangerouslySetInnerHTML применяют в приложениях, где нужно отобразить отформатированный текст в элементе div.
Однако использование dangerouslySetInnerHTML может представлять угрозу безопасности, т.к.
оно открывает возможности для атак типа XSS, если вставляемый HTML-код не фильтруется и не обезвреживается.
Поэтому при использовании dangerouslySetInnerHTML следует быть осторожным и всегда обезвреживать любой пользовательский ввод,
который может быть вставлен в качестве HTML.

    Для этой цели можно использовать библиотеку isomorphic-dompurify. В отличие от dompurify isomorphic-dompurify не
вызывает ошибок в SSR.
    import DOMPurify from "isomorphic-dompurify";
    <div dangerouslySetInnerHTML={ { __html: DOMPurify.sanitize(post?.content) } }></div>

2. Генерация надёжного секретного ключа
    $ openssl rand -hex 32

3. Кодирование секретного ключа
    const secretKey = process.env.SESSION_SECRET_KEY!;
    //Кодируем секретный ключ
    //Принимает строку в качестве входных данных и возвращает Uint8Arrayсодержащий ее текст в кодировке UTF-8.
    export const ENCODED_KEY = new TextEncoder().encode(secretKey);

 4. Определения
    JSON Web Token (JWT) — это открытый стандарт (RFC 7519) для создания токенов доступа,
    основанный на формате JSON.
    Как правило, используется для передачи данных для аутентификации в клиент-серверных приложениях.
    Так как JWT передается в открытом виде,
    для получения хранящихся в части полезной нагрузки исходных данных достаточно применить к этой части функцию base64UrlDecode.
    То есть злоумышленник, перехвативший токен, сможет извлечь хранящиеся в токене данные о пользователе.

    CORS (Cross-Origin Resource Sharing,
    англ. «совместное использование ресурсов разных источников») —
    это стандарт, позволяющий предоставлять веб-страницам доступ к объектам сторонних интернет-ресурсов.

    CSRF (англ. cross-site request forgery — «межсайтовая подделка запроса».
    Подделка межсайтовых запросов (CSRF) — это атака, при которой вредоносный сайт отправляет запрос на уязвимый сайт,
    где пользователь в данный момент вошел в систему.
    CSRF (cross-site request forgery, подделка межсайтовых запросов) — вид атак на сайт,
    при которой злоумышленник с помощью мошеннического сайта или скрипта
    заставляет браузер пользователя выполнять на доверенном сайте действия от его имени: отправлять сообщения, менять пароли, переводить деньги со счета на счет и пр.

    OAuth — стандарт (схема) авторизации,
    обеспечивающий предоставление третьей стороне ограниченного доступа к защищённым ресурсам пользователя
    без передачи ей (третьей стороне) логина и пароля.

  5. Атрибут cookies SameSite
  В обновленный атрибут SameSite передаются три значения:
   Strict, Lax или None.
   Если не указано, атрибут SameSite файлов cookie по умолчанию принимает значение SameSite=Lax .
   Файлы cookie автоматически отправляются только в контексте первой стороны и с запросами HTTP GET.
   При SameSite=Lax браузеры будут отправлять cookie в межсайтовых запросах,
   но только если выполняются оба следующих условия:
    1) Запрос использует метод GET.
    2) Запрос был получен в результате навигации верхнего уровня пользователем,
    например, при нажатии на ссылку.

  6. Параметры настройкиcookies
     cookies().set('session', session, {
        //Предотвращает доступ к JWT+токену через JavaScript стороне клиента
        httpOnly: true,
        //Передавать cookies только если используется протокол HTTPS
        secure: process.env.NODE_ENV === 'production',
        //Устанавливает cookies только для текущего домена
        //Предотвращает передачу cookies другим доменам (защита от CSRF-атак)
        sameSite: 'lax',
        //Определяет маршрут, в пределах которого будут доступны cookies.
        //Он должен быть абсолютным, то есть начинаться со /.
        //Если параметр не передан, то cookies будет доступна на всех страницах сайта.
        //В данном случае - cookies доступны во всех маршрутах нашего приложения.
        path: '/',
        expires: expiredAt,
      });